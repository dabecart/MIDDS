/***************************************************************************************************
 * @file MainMCU.c
 * @brief Start and main loop of the MCU. Keeps the autogenerated code from STM32 separated from the 
 * human written code.
 * 
 * @project MIDDS
 * @version 1.0
 * @date    2025-07-29
 * @author  @dabecart
 * 
 * @license This project is licensed under the MIT License - see the LICENSE file for details.
***************************************************************************************************/

#include "MainMCU.h"

HWTimers hwTimers;
ChannelController chCtrl;

void initMCU(TIM_HandleTypeDef* htim1,
             TIM_HandleTypeDef* htim2, 
             TIM_HandleTypeDef* htim3, 
             TIM_HandleTypeDef* htim4,
             TIM_HandleTypeDef* htim5,
             SPI_HandleTypeDef* hspi1,
             I2C_HandleTypeDef* hi2c1,
             I2C_HandleTypeDef* hi2c2)
{
    initComms();

    initHWTimers(&hwTimers, htim1, htim2, htim3, htim4, htim5);

    initChannelController(&chCtrl, hspi1, hi2c1, hi2c2);
    
    startHWTimers(&hwTimers);

    // // Wait for a few seconds and try to grab any SYNC pulse.
    // HAL_Delay(3000);

    // if(hwTimers.measuredPeriodHighSYNC != 0 || hwTimers.measuredPeriodLowSYNC != 0) {
    //     // It is using a SYNC pulse, clear all current buffers.
    //     for(uint16_t i = 0; i < HW_TIMER_CHANNEL_COUNT; i++) {
    //         clearHWTimer(hwTimers.channels+i);
    //     }
    // }
}

void loopMCU() {
    // Receive commands and generate the responses.
    receiveData();

    // Generate the recurrent messages.
    ChannelMessage tempMsg = {};
    Channel* ch;
    for(uint16_t i = 0; i < HW_TIMER_CHANNEL_COUNT; i++) {
        ch = chCtrl.channels + i;

        // Recurrent message for Monitor mode.
        if((ch->mode == CHANNEL_MONITOR_BOTH_EDGES) || 
           (ch->mode == CHANNEL_MONITOR_RISING_EDGES) || 
           (ch->mode == CHANNEL_MONITOR_FALLING_EDGES)) {
            if((ch->type == CHANNEL_TIMER) && readyToPrintHWTimer(ch->data.timer.timerHandler)) {
                tempMsg.monitor = ch->data.timer.timerHandler;
                encodeGPIOMessage(GPIO_MSG_MONITOR, tempMsg); 
            }else if(ch->type == CHANNEL_GPIO) {
                // TODO: Not implemented.
                continue;
            }
        }
    }

    // Send the data.
    sendData();
}
